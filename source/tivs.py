import numpy as np
from numpy.linalg import norm

KEY_PROFILES = {
    'major': np.array([
        [5.95442650e-02 +0.05954426j,  8.13389786e-02 +0.02179471j,
         8.13389786e-02 -0.02179471j,  5.95442650e-02 -0.05954426j,
         2.17947136e-02 -0.08133898j, -2.17947136e-02 -0.08133898j,
        -5.95442650e-02 -0.05954426j, -8.13389786e-02 -0.02179471j,
        -8.13389786e-02 +0.02179471j, -5.95442650e-02 +0.05954426j,
        -2.17947136e-02 +0.08133898j,  2.17947136e-02 +0.08133898j],
        [2.44444444e+00 +0.j        ,  1.22222222e+00 -2.11695099j,
        -1.22222222e+00 -2.11695099j, -2.44444444e+00 +0.j        ,
        -1.22222222e+00 +2.11695099j,  1.22222222e+00 +2.11695099j,
         2.44444444e+00 +0.j        ,  1.22222222e+00 -2.11695099j,
        -1.22222222e+00 -2.11695099j, -2.44444444e+00 +0.j        ,
        -1.22222222e+00 +2.11695099j,  1.22222222e+00 +2.11695099j],
        [3.77777778e+00 +1.88888889j,  1.88888889e+00 -3.77777778j,
        -3.77777778e+00 -1.88888889j, -1.88888889e+00 +3.77777778j,
         3.77777778e+00 +1.88888889j,  1.88888889e+00 -3.77777778j,
        -3.77777778e+00 -1.88888889j, -1.88888889e+00 +3.77777778j,
         3.77777778e+00 +1.88888889j,  1.88888889e+00 -3.77777778j,
        -3.77777778e+00 -1.88888889j, -1.88888889e+00 +3.77777778j],
        [0.00000000e+00 +0.j        ,  0.00000000e+00 +0.j        ,
        -9.86864911e-16 +0.j        ,  7.89491929e-16 +0.j        ,
         0.00000000e+00 +0.j        ,  7.89491929e-16 +0.j        ,
         0.00000000e+00 +0.j        , -7.89491929e-16 +0.j        ,
         1.97372982e-16 +0.j        , -7.89491929e-16 +0.j        ,
         7.89491929e-16 +0.j        ,  0.00000000e+00 +0.j        ],
        [7.87877393e+00 +7.87877393j, -2.88383141e+00-10.76260534j,
        -2.88383141e+00+10.76260534j,  7.87877393e+00 -7.87877393j,
        -1.07626053e+01 +2.88383141j,  1.07626053e+01 +2.88383141j,
        -7.87877393e+00 -7.87877393j,  2.88383141e+00+10.76260534j,
         2.88383141e+00-10.76260534j, -7.87877393e+00 +7.87877393j,
         1.07626053e+01 -2.88383141j, -1.07626053e+01 -2.88383141j],
       [-7.77777778e-01 +0.j        ,  7.77777778e-01 +0.j        ,
        -7.77777778e-01 +0.j        ,  7.77777778e-01 +0.j        ,
        -7.77777778e-01 +0.j        ,  7.77777778e-01 +0.j        ,
        -7.77777778e-01 +0.j        ,  7.77777778e-01 +0.j        ,
        -7.77777778e-01 +0.j        ,  7.77777778e-01 +0.j        ,
        -7.77777778e-01 +0.j        ,  7.77777778e-01 +0.j        ]
    ]),
    
    'minor': np.array([
        [-2.17947136e-02 +0.08133898j,  2.17947136e-02 +0.08133898j,
         5.95442650e-02 +0.05954426j,  8.13389786e-02 +0.02179471j,
         8.13389786e-02 -0.02179471j,  5.95442650e-02 -0.05954426j,
         2.17947136e-02 -0.08133898j, -2.17947136e-02 -0.08133898j,
        -5.95442650e-02 -0.05954426j, -8.13389786e-02 -0.02179471j,
        -8.13389786e-02 +0.02179471j, -5.95442650e-02 +0.05954426j],
        [1.22222222e+00 -2.11695099j, -1.22222222e+00 -2.11695099j,
        -2.44444444e+00 +0.j        , -1.22222222e+00 +2.11695099j,
         1.22222222e+00 +2.11695099j,  2.44444444e+00 +0.j        ,
         1.22222222e+00 -2.11695099j, -1.22222222e+00 -2.11695099j,
        -2.44444444e+00 +0.j        , -1.22222222e+00 +2.11695099j,
         1.22222222e+00 +2.11695099j,  2.44444444e+00 +0.j        ],
        [1.88888889e+00 +3.77777778j,  3.77777778e+00 -1.88888889j,
        -1.88888889e+00 -3.77777778j, -3.77777778e+00 +1.88888889j,
         1.88888889e+00 +3.77777778j,  3.77777778e+00 -1.88888889j,
        -1.88888889e+00 -3.77777778j, -3.77777778e+00 +1.88888889j,
         1.88888889e+00 +3.77777778j,  3.77777778e+00 -1.88888889j,
        -1.88888889e+00 -3.77777778j, -3.77777778e+00 +1.88888889j],
        [0.00000000e+00 +0.j        , -7.89491929e-16 +0.j        ,
         0.00000000e+00 +0.j        ,  7.89491929e-16 +0.j        ,
        -1.97372982e-16 +0.j        ,  7.89491929e-16 +0.j        ,
        -7.89491929e-16 +0.j        ,  0.00000000e+00 +0.j        ,
         0.00000000e+00 +0.j        ,  0.00000000e+00 +0.j        ,
         9.86864911e-16 +0.j        , -7.89491929e-16 +0.j        ],
        [1.07626053e+01 -2.88383141j, -1.07626053e+01 -2.88383141j,
         7.87877393e+00 +7.87877393j, -2.88383141e+00-10.76260534j,
        -2.88383141e+00+10.76260534j,  7.87877393e+00 -7.87877393j,
        -1.07626053e+01 +2.88383141j,  1.07626053e+01 +2.88383141j,
        -7.87877393e+00 -7.87877393j,  2.88383141e+00+10.76260534j,
         2.88383141e+00-10.76260534j, -7.87877393e+00 +7.87877393j],
        [7.77777778e-01 +0.j        , -7.77777778e-01 +0.j        ,
         7.77777778e-01 +0.j        , -7.77777778e-01 +0.j        ,
         7.77777778e-01 +0.j        , -7.77777778e-01 +0.j        ,
         7.77777778e-01 +0.j        , -7.77777778e-01 +0.j        ,
         7.77777778e-01 +0.j        , -7.77777778e-01 +0.j        ,
         7.77777778e-01 +0.j        , -7.77777778e-01 +0.j        ]
    ]),
    
    'harmonic': np.array([
        [ 5.95442650e-02+2.46716228e-17j,  5.15668461e-02-2.97721325e-02j,
         2.97721325e-02-5.15668461e-02j,  0.00000000e+00-5.95442650e-02j,
        -2.97721325e-02-5.15668461e-02j, -5.15668461e-02-2.97721325e-02j,
        -5.95442650e-02+0.00000000e+00j, -5.15668461e-02+2.97721325e-02j,
        -2.97721325e-02+5.15668461e-02j, -2.46716228e-17+5.95442650e-02j,
         2.97721325e-02+5.15668461e-02j,  5.15668461e-02+2.97721325e-02j],
        [2.44444444e+00-2.11695099e+00j, -6.11111111e-01-3.17542648e+00j,
        -3.05555556e+00-1.05847549e+00j, -2.44444444e+00+2.11695099e+00j,
         6.11111111e-01+3.17542648e+00j,  3.05555556e+00+1.05847549e+00j,
         2.44444444e+00-2.11695099e+00j, -6.11111111e-01-3.17542648e+00j,
        -3.05555556e+00-1.05847549e+00j, -2.44444444e+00+2.11695099e+00j,
         6.11111111e-01+3.17542648e+00j,  3.05555556e+00+1.05847549e+00j],
        [3.77777778e+00+5.66666667e+00j,  5.66666667e+00-3.77777778e+00j,
        -3.77777778e+00-5.66666667e+00j, -5.66666667e+00+3.77777778e+00j,
         3.77777778e+00+5.66666667e+00j,  5.66666667e+00-3.77777778e+00j,
        -3.77777778e+00-5.66666667e+00j, -5.66666667e+00+3.77777778e+00j,
         3.77777778e+00+5.66666667e+00j,  5.66666667e+00-3.77777778e+00j,
        -3.77777778e+00-5.66666667e+00j, -5.66666667e+00+3.77777778e+00j],
        [0.00000000e+00+3.07920144e+00j,  2.66666667e+00-1.53960072e+00j,
        -2.66666667e+00-1.53960072e+00j,  7.89491929e-16+3.07920144e+00j,
         2.66666667e+00-1.53960072e+00j, -2.66666667e+00-1.53960072e+00j,
        -7.89491929e-16+3.07920144e+00j,  2.66666667e+00-1.53960072e+00j,
        -2.66666667e+00-1.53960072e+00j,  0.00000000e+00+3.07920144e+00j,
         2.66666667e+00-1.53960072e+00j, -2.66666667e+00-1.53960072e+00j],
        [7.87877393e+00+0.00000000e+00j, -6.82321837e+00-3.93938696e+00j,
         3.93938696e+00+6.82321837e+00j,  0.00000000e+00-7.87877393e+00j,
        -3.93938696e+00+6.82321837e+00j,  6.82321837e+00-3.93938696e+00j,
        -7.87877393e+00+0.00000000e+00j,  6.82321837e+00+3.93938696e+00j,
        -3.93938696e+00-6.82321837e+00j,  0.00000000e+00+7.87877393e+00j,
         3.93938696e+00-6.82321837e+00j, -6.82321837e+00+3.93938696e+00j],
       [-7.77777778e-01+0.00000000e+00j,  7.77777778e-01+0.00000000e+00j,
        -7.77777778e-01+0.00000000e+00j,  7.77777778e-01+0.00000000e+00j,
        -7.77777778e-01+0.00000000e+00j,  7.77777778e-01+0.00000000e+00j,
        -7.77777778e-01+0.00000000e+00j,  7.77777778e-01+0.00000000e+00j,
        -7.77777778e-01+0.00000000e+00j,  7.77777778e-01+0.00000000e+00j,
        -7.77777778e-01+0.00000000e+00j,  7.77777778e-01+0.00000000e+00j]
    ])
}


'''
For symbolic data, use weights = [2, 11, 17, 16, 19, 7].
For audio data, use weights = [3, 8, 11.5, 15, 14.5, 7.5]
'''
def compute_progression_tivs(progression, weights=[3, 8, 11.5, 15, 14.5, 7.5]):
    """
    Function to compute the TIV representation of a progression of shape (12, seq_length).
    This function returns a complex array of shape (6, seq_length).

    Additionaly, you can specify the weights used in the computation. To use Harte et al. 6-D Tonnetz
    representation, set weights=[0, 0, 1, .5, 1, 0]
    """

    if type(weights) != np.ndarray:
        weights = np.array(weights)

    fft_values = np.fft.rfft(progression, n=12, axis=0)
    energy, tivs = fft_values[0], fft_values[1:7]

    for i in range(len(energy)):
        if energy[i] != 0:
            tivs[:, i] = weights * (tivs[:, i] / energy[i])
    
    return energy, tivs


def compute_similarity(tivs1, tivs2):
    '''
    Expected that tivs1 have shape (N, 6) and tivs2 shape (6, M).
    The result will be (N, M), meaning the similarity from every row N with every column M.
    '''
    # Splitting real and imaginary part into 12-D vectors
    tivs1 = np.concatenate([tivs1.real, tivs1.imag], axis=1)
    tivs2 = np.concatenate([tivs2.real, tivs2.imag])

    tivs1 /= (np.linalg.norm(tivs1, axis=1, keepdims=True) + 1e-6)
    tivs2 /= (np.linalg.norm(tivs2, axis=0, keepdims=True) + 1e-6)

    sim = np.dot(tivs1, tivs2)
    return sim


def combine_tivs(energy, tivs):
    '''
    TIVs combination is given by linear combination of TIVs with their respective energies.
    The energies are retrived from T(0). 
    '''
    return np.sum(energy * tivs, axis=1, keepdims=True) / (np.sum(energy) + 1e-6)


def compute_key_similarities(tivs):
    '''
    Key similarity computation expects TIV representation with shape (6, N).
    '''
    
    major_similarities = compute_similarity(KEY_PROFILES['major'].T, tivs)
    aeolian_similarities = compute_similarity(KEY_PROFILES['minor'].T, tivs)
    harmonic_similarities = compute_similarity(KEY_PROFILES['harmonic'].T, tivs)

    minor_similarities = np.stack([aeolian_similarities, harmonic_similarities])
    minor_similarities = np.max(minor_similarities, axis=0)  # getting the max of aeolian vs. harmonic minor

    key_similarities = np.vstack([major_similarities, minor_similarities])     
    return key_similarities


def compute_magphase(tiv):
    magphase = np.concatenate([np.abs(tiv), np.angle(tiv)])
    return magphase


def compute_pmd(magphase):
    def wrap_phase(phase):
        return ((phase + np.pi) % (2 * np.pi)) - np.pi
    
    first = magphase[:, 0][:, np.newaxis]  # adding axis so that the diff works correctly
    displacement = np.diff(magphase, axis=1, prepend=first)

    # Wrapping phase values in range [-pi, pi]
    displacement[6:, :] = wrap_phase(displacement[6:, :])

    return displacement